# redis 最佳实践

本文将是我从业多年来学到的redis之精华，现总结如下以供日后参考回味
更多精彩请关注如下链接

- [Redis 命令参考](http://doc.redisfans.com/)

## redis运维需求
- 部署单节点
```
本文只提供docker版本安装部署，参考如下
1. pull镜像
> docker pull redis:5.0.0
2. 运行镜像
> docker run --name redids-local-single -p 6379:76379 -d redis
3. 查看示例运行情况
> docker ps | grep redis 
> docker logs -f redis-local-single
linux环境
> docker exec -it r redis-local-single redis-cli
win 10 环境
> winpty docker exec -it r redis-local-single redis-cli

 
```

- 部署集群
```






```


- 高可用
```



```
- 备份机制



## redis数据结构
- string
```
> winpty docker exec -it redis-local-single redis-cli
> keys *
> set name "klaus"
> get name

```


- hash
- set
- zset

## redis常用命令
```
1. get/set key
2. keys *
3. scan
4. hget
 

```

## redis 常用业务使用场景
- 存储热数据
- 统计
- 排名
- 发布/订阅
- 分布式锁
```
https://blog.csdn.net/Ethan_199402/article/details/102575130



```





## redis使用过程中存在的问题
- 缓存击穿
```
因为缓存服务失效等大量请求直接请求后端数据库
即缓存击穿是当数据是存在的，但没有被缓存到
```
- 缓存穿透
```
在高并发下，查询一个不存在的值时，缓存不会被命中，导致大量请求直接落到数据库上，如活动系统里面查询一个不存在的活动
即缓存穿透是去访问根本不存在的值

布隆过滤器不能100%判断一个元素是否真的存在数组中，但能100%判断它不存在与数组中，这取决于hash函数的算法程度

布隆过滤器防止缓存穿透

```
- 缓存雪崩
```
如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。

其实与缓存击穿的理论差不多，都是突然失效导致的击穿数据库
```
- 缓存一致性
```
数据库的数据和缓存的数据是不可能一致的，数据分为最终一致和强一致两类。

强一致 不可以使用缓存

缓存能做的只能保证数据的最终一致性。

我们能做的只能是尽可能的保证数据的一致性。

不管是先删库再删缓存 还是 先删缓存再删库，都可能出现数据不一致的情况，因为读和写操作是并发的，我们没办法保证他们的先后顺序。

具体应对策略根据业务需求来制订
```
- 缓存过期与淘汰
```
Redis设置的过期时间。这个key过期时是怎么删除的？

Redis采用的是定期删除，注意不是定时删除，不可能为每一个key做一个定时任务去监控删除，这样会耗尽服务器资源。

默认是每100ms检测一次，遇到过期的key则进行删除，这里的检测也不是顺序检测，而是随机检测。

另外为了防止有漏网之鱼，例如在100ms检查的中间间隙，某个key过期，但同时key访问又进来了，这时触发 惰性删除策略 redis会在读取时判断是否已经过期，过期则直接删除。

内存淘汰是指一部分key在内存不够用的情况下会被Redis自动删除，从而会出现从缓存中查不到数据的情况。

例如我们的服务器内存为2G、但是随着业务的发展缓存的数据已经超过2G了。但是这并不能影响我们程序的运行。所以redis会从key列表中抽取一定的热度低的数据进行淘汰策略，腾出空间存储新的key
```

## 使用技巧

- 为项目设置统一的key前缀，防止第三方应用干扰
- key过期时间统一加上随机值

